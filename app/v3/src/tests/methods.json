{
  "algorithms": [
    {
      "description":
        "Histogram of nominal or continuous variable grouped by nominal variables in independent variables.",
      "label": "Histograms",
      "code": "histograms",
      "docker_image": "hbpmip/python-histograms:0.6.1",
      "constraints": {
        "covariables": { "min_count": 0 },
        "groupings": { "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": false,
          "integer": true,
          "polynominal": false,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["statistics"]
    },
    {
      "description":
        "Summary statistics for both nominal and continuous variables grouped by nominal variables.",
      "label": "Statistics Summary",
      "code": "statisticsSummary",
      "docker_image": "hbpmip/python-summary-statistics:0.4.0",
      "constraints": {
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "python",
      "type": ["statistics"]
    },
    {
      "description":
        "Standard Linear Regression (or Logistic Regression for nominal variables).",
      "label": "Linear Regression",
      "code": "linearRegression",
      "docker_image": "hbpmip/python-linear-regression:0.3.1",
      "constraints": {
        "covariables": { "min_count": 1 },
        "groupings": { "max_count": 1, "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["statistics"],
      "parameters": []
    },
    {
      "description":
        "Linear model trained with Stochastic Gradient Descent. Works with both continuous or nominal variables (logistic regression)",
      "label": "SGD Linear model",
      "code": "sgdLinearModel",
      "docker_image": "hbpmip/python-sgd-linear-model:0.3.3",
      "constraints": {
        "covariables": { "min_count": 1 },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["predictive_model"],
      "parameters": [
        {
          "description":
            "Constant that multiplies the regularization term. Defaults to 0.0001 Also used to compute learning_rate when set to ‘optimal’.",
          "label": "Alpha",
          "code": "alpha",
          "constraints": { "min": 0.0 },
          "default_value": 0.0001,
          "type": "number"
        },
        {
          "description":
            "The penalty (aka regularization term) to be used. Defaults to ‘l2’ which is the standard regularizer for linear SVM models. ‘l1’ and ‘elasticnet’ might bring sparsity to the model (feature selection) not achievable with ‘l2’.",
          "label": "Penalty",
          "code": "penalty",
          "default_value": "l2",
          "values": ["none", "l2", "l1", "elasticnet"],
          "type": "enumeration"
        },
        {
          "description":
            "The Elastic Net mixing parameter, with 0 \u003c\u003d L1 ratio \u003c\u003d 1. L1 ratio\u003d0 corresponds to L2 penalty, L1 ratio\u003d1 to L1. Defaults to 0.15.",
          "label": "L1 ratio",
          "code": "l1_ratio",
          "constraints": { "max": 1.0, "min": 0.0 },
          "default_value": 0.15,
          "type": "number"
        }
      ]
    },
    {
      "description":
        "Naive Bayes trained with Stochastic Gradient Descent that can handle both continuous and nominal covariables. Only works for classification.",
      "label": "Naive Bayes",
      "code": "naiveBayes",
      "docker_image": "hbpmip/python-sgd-naive-bayes:0.3.3",
      "constraints": {
        "covariables": { "min_count": 1 },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": true,
          "integer": false,
          "polynominal": true,
          "real": false
        }
      },
      "environment": "Python",
      "type": ["predictive_model"],
      "parameters": [
        {
          "description":
            "Additive (Laplace/Lidstone) smoothing parameter (0 for no smoothing, default to 1.)",
          "label": "Alpha",
          "code": "alpha",
          "constraints": { "max": 1.0, "min": 0.0 },
          "default_value": 1.0,
          "type": "number"
        },
        {
          "description":
            "Prior probabilities of the classes. If specified the priors are not adjusted according to the data. Must be numbers between 0 and 1 and sum to 1. Pass real values separated by comma.",
          "label": "Class prior",
          "code": "class_prior",
          "default_value": "",
          "type": "string"
        }
      ]
    },
    {
      "description":
        "Feedforward Neural Network trained with Stochastic Gradient Descent for both regression and classification.",
      "label": "SGD Neural Network",
      "code": "sgdNeuralNetwork",
      "docker_image": "hbpmip/python-sgd-neural-network:0.3.3",
      "constraints": {
        "covariables": { "min_count": 1 },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["predictive_model"],
      "parameters": [
        {
          "description":
            "The ith element represents the number of neurons in the ith hidden layer. Pass integers separated by comma.",
          "label": "Hidden layer sizes",
          "code": "hidden_layer_sizes",
          "default_value": "100",
          "type": "string"
        },
        {
          "description": "Activation function for the hidden layer.",
          "label": "Activation",
          "code": "activation",
          "default_value": "relu",
          "values": ["identity", "logistic", "tanh", "relu"],
          "type": "enumeration"
        },
        {
          "description": "L2 penalty (regularization term) parameter.",
          "label": "Alpha",
          "code": "alpha",
          "constraints": { "min": 0.0 },
          "default_value": 0.0001,
          "type": "number"
        },
        {
          "description":
            "The initial learning rate used. It controls the step-size in updating the weights.",
          "label": "Initial learning rate",
          "code": "learning_rate_init",
          "constraints": { "max": 1.0, "min": 0.0 },
          "default_value": 0.001,
          "type": "number"
        }
      ]
    },
    {
      "description":
        "Gradient Boosting for both regression and classification. Produces prediction model in the form of an ensemble of weak prediction models (decision trees).",
      "label": "Gradient Boosting",
      "code": "gradientBoosting",
      "docker_image": "hbpmip/python-gradient-boosting:0.3.3",
      "constraints": {
        "covariables": { "min_count": 1 },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["predictive_model"],
      "parameters": [
        {
          "description":
            "learning rate shrinks the contribution of each tree by learning_rate. There is a trade-off between learning_rate and n_estimators.",
          "label": "Learning rate",
          "code": "learning_rate",
          "constraints": { "max": 1.0, "min": 0.0 },
          "default_value": 0.1,
          "type": "number"
        },
        {
          "description":
            "The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.",
          "label": "Number of estimators",
          "code": "n_estimators",
          "constraints": { "min": 0 },
          "default_value": 100,
          "type": "int"
        },
        {
          "description":
            "maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.",
          "label": "Maximum depth",
          "code": "max_depth",
          "constraints": { "max": 10, "min": 1 },
          "default_value": 3,
          "type": "int"
        },
        {
          "description":
            "The minimum number of samples required to split an internal node.",
          "label": "Minimum samples for split",
          "code": "min_samples_split",
          "constraints": { "min": 1 },
          "default_value": 2,
          "type": "int"
        },
        {
          "description":
            "The minimum number of samples required to be at a leaf node.",
          "label": "Minimum samples for leaf",
          "code": "min_samples_leaf",
          "constraints": { "min": 1 },
          "default_value": 1,
          "type": "int"
        },
        {
          "description":
            "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.",
          "label": "Minimum weighted fraction for leaf",
          "code": "min_weight_fraction_leaf",
          "constraints": { "max": 1.0, "min": 0.0 },
          "default_value": 0.0,
          "type": "number"
        },
        {
          "description":
            "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
          "label": "Minimum impurity decrease",
          "code": "min_impurity_decrease",
          "constraints": { "min": 0.0 },
          "default_value": 0.0,
          "type": "number"
        }
      ]
    },
    {
      "description":
        "Analysis of variance (ANOVA) for analyzing differences among group means. Supports factorial and additive design.",
      "label": "Anova",
      "code": "anova",
      "docker_image": "hbpmip/python-anova:0.4.4",
      "constraints": {
        "covariables": { "min_count": 0 },
        "groupings": { "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": false,
          "integer": true,
          "polynominal": false,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["statistics"],
      "parameters": [
        {
          "description":
            "The type of multi-factors design. Choose \u0027factorial\u0027 to enable interactions analysis or \u0027additive\u0027 for a model without no interaction at all.",
          "label": "Design",
          "code": "design",
          "default_value": "factorial",
          "values": ["factorial", "additive"],
          "type": "enumeration"
        }
      ]
    },
    {
      "description":
        "K-nearest neighbors is a non-parametric method used for classification and regression that makes prediction based on K closest training examples.",
      "label": "K-nearest neighbors",
      "code": "knn",
      "docker_image": "hbpmip/python-knn:0.4.0",
      "constraints": {
        "covariables": { "min_count": "1" },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": false,
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["predictive_model"],
      "parameters": [
        {
          "description":
            "The number of closest neighbours to take into consideration. Typical values range from 2 to 10.",
          "label": "Number of neighbours",
          "code": "k",
          "constraints": { "min": 1 },
          "default_value": 5,
          "type": "int"
        }
      ]
    },
    {
      "description":
        "Correlation heatmap shows dependence between continuous random variables. For nominal variables it shows pairwise cross-tabs.",
      "label": "Correlation heatmap",
      "code": "correlationHeatmap",
      "docker_image": "hbpmip/python-correlation-heatmap:0.4.1",
      "constraints": {
        "covariables": { "min_count": "1" },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": false,
        "variable": {
          "binominal": false,
          "integer": true,
          "polynominal": false,
          "real": true
        }
      },
      "environment": "python",
      "type": ["statistics"]
    },
    {
      "description":
        "Principal Components Analysis (PCA) performs dimensionality reduction on data and shows biplot of the first two principal components.",
      "label": "PCA",
      "code": "pca",
      "docker_image": "hbpmip/python-distributed-pca:0.4.1",
      "constraints": {
        "covariables": { "min_count": "1" },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": false,
        "variable": {
          "binominal": false,
          "integer": true,
          "polynominal": false,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["statistics"],
      "parameters": []
    },
    {
      "description":
        "The Hedwig algorithm for subgroup discovery is a data mining algorithm designed for exploratory data analysis of a data set",
      "label": "JSI Hedwig",
      "code": "hedwig",
      "docker_image": "hbpmip/python-jsi-hedwig:1.0.7",
      "constraints": {
        "covariables": { "min_count": "1" },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": true,
          "integer": false,
          "polynominal": true,
          "real": false
        }
      },
      "environment": "Python",
      "type": ["features_extraction"],
      "parameters": [
        {
          "description":
            "The size of the beam to be used in the search. Larger values of this variable cause the search of the algorithm to take longer and return more high quality rules.",
          "label": "Size of the beam",
          "code": "beam",
          "constraints": { "min": 1 },
          "default_value": 10,
          "type": "int"
        },
        {
          "description":
            "The minimum relative support of the rules, discovered by Hedwig. The value of this parameter must be between 0 and 1 as the parameter represents the ration of the covered examples in the entire data set.",
          "label": "Minimum relative support",
          "code": "support",
          "constraints": { "max": 1.0, "min": 0.0 },
          "default_value": 0.1,
          "type": "number"
        }
      ]
    },
    {
      "description":
        "The HINMINE algorithm for network-based propositionalization is an algorithm for data analysis based on network analysis methods",
      "label": "JSI Hinmine",
      "code": "hinmine",
      "docker_image": "hbpmip/python-jsi-hinmine:0.3.0",
      "constraints": {
        "covariables": { "min_count": "1" },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": false,
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["features_extraction"],
      "parameters": [
        {
          "description":
            "Check if the algorithm should first normalize the data. Data normalization normalizes the range of each feature to [-1, 1] and can be useful when comparing two instances. However, if two features have different values for a non-arbitrary reason, normalization should not be performed",
          "label": "Normalize data",
          "code": "normalize",
          "default_value": "true",
          "type": "boolean"
        },
        {
          "description":
            "Damping factor of the PageRank algorithm used in calculating feature values for the data instances. It represents the probability of a random walker in a network to continue its random walk as oposed to teleporting to a random node",
          "label": "Damping factor",
          "code": "0.85",
          "constraints": { "max": 1.0, "min": 0.0 },
          "default_value": 0.85,
          "type": "number"
        }
      ]
    },
    {
      "description":
        "tSNE is a machine learning algorithm for nonlinear dimensionality reduction. It embeds high-dimensional data for visualization in a low-dimensional space of two or three dimensions.",
      "label": "tSNE",
      "code": "tSNE",
      "docker_image": "hbpmip/python-tsne:0.4.2",
      "constraints": {
        "covariables": { "min_count": 1 },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": false,
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "Python",
      "disable": false,
      "type": ["features_extraction"],
      "parameters": []
    },
    {
      "maturity": "experimental",
      "description":
        "Parallel coordinates plot with added confidence interval bands",
      "label": "TAU ggparci",
      "code": "ggparci",
      "docker_image": "hbpmip/r-ggparci:0.2.1",
      "constraints": {
        "covariables": { "min_count": 1 },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "R",
      "disable": false,
      "type": ["features_extraction"],
      "parameters": []
    },
    {
      "description":
        "K-means is a method for vector quantization used for cluster analysis.",
      "label": "Distributed K-means",
      "code": "kmeans",
      "docker_image": "hbpmip/python-distributed-kmeans:0.2.1",
      "constraints": {
        "covariables": { "min_count": "1" },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": false,
        "variable": {
          "binominal": false,
          "integer": true,
          "polynominal": false,
          "real": true
        }
      },
      "environment": "Python",
      "type": ["features_extraction"],
      "parameters": [
        {
          "description":
            "The number of clusters. The final number of clusters is also influenced by the number of nodes - total number of output clusters is floor(n_clusters * n_nodes / 2).",
          "label": "Number of clusters",
          "code": "n_clusters",
          "constraints": { "min": 1 },
          "default_value": 3,
          "type": "int"
        }
      ]
    },
    {
      "maturity": "experimental",
      "description": "Interactive Heat Maps",
      "label": "TAU Heatmaply",
      "code": "heatmaply",
      "docker_image": "hbpmip/r-heatmaply:0.2.0",
      "constraints": {
        "covariables": { "min_count": 1 },
        "groupings": { "max_count": 0, "min_count": 0 },
        "mixed": true,
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      },
      "environment": "R",
      "disable": false,
      "type": ["features_extraction"],
      "parameters": []
    },
    {
      "code": "WP_VARIABLES_HISTOGRAM",
      "label": " Histogram",
      "type": ["statistics"],
      "environment": "Exareme",
      "description": "Histograms",
      "parameters": [
        {
          "code": "nobuckets",
          "label": "nobuckets",
          "default_value": 4,
          "type": "int",
          "constraints": { "min": 1 },
          "description":
            "The number of clusters. Typical values range from 2 to 10."
        }
      ],
      "constraints": {
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      }
    },
    {
      "code": "PIPELINE_ISOUP_REGRESSION_TREE_SERIALIZER",
      "label": " Regression Tree",
      "type": ["statistics"],
      "environment": "Exareme",
      "description": "Regression Tree Serializer",
      "parameters": [],
      "constraints": {
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      }
    },
    {
      "code": "PIPELINE_ISOUP_MODEL_TREE_SERIALIZER",
      "label": "Model Tree",
      "type": ["statistics"],
      "environment": "Exareme",
      "description": "Model Tree Serializer",
      "parameters": [],
      "constraints": {
        "variable": {
          "binominal": true,
          "integer": true,
          "polynominal": true,
          "real": true
        }
      }
    },
    {
      "code": "WP_LINEAR_REGRESSION",
      "label": "Linear regression",
      "type": ["statistics"],
      "environment": "Exareme",
      "description": "Linear Regression using Exareme services",
      "parameters": [
        {
          "code": "design",
          "default_value": "factorial",
          "description":
            "The type of multi-factors design. Choose \u0027factorial\u0027 to enable interactions analysis or \u0027additive\u0027 for a model without no interaction at all.",
          "label": "design",
          "type": "enumeration",
          "values": ["factorial", "additive"]
        }
      ],
      "constraints": {
        "variable": {
          "binominal": false,
          "integer": true,
          "polynominal": false,
          "real": true
        }
      }
    },
    {
      "code": "K_MEANS",
      "label": "K_MEANS",
      "type": ["statistics"],
      "environment": "Exareme",
      "description": "k-Means using Exareme services",
      "parameters": [
        {
          "code": "k",
          "label": "k",
          "default_value": 5,
          "type": "int",
          "constraints": { "min": 1 },
          "description":
            "The number of clusters. Typical values range from 2 to 10."
        }
      ],
      "constraints": {
        "variable": {
          "real": true,
          "integer": true,
          "binominal": true,
          "polynominal": true
        },
        "groupings": { "min_count": 0, "max_count": 0 },
        "covariables": { "min_count": "1" },
        "mixed": false
      }
    }
  ],
  "metrics": {
    "binominal_classification": [
      {
        "code": "Confusion matrix",
        "label": "Confusion matrix",
        "tooltip": "To be completed",
        "type": "confusion_matrix"
      },
      {
        "code": "Accuracy",
        "label": "Mean square error",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "Precision",
        "label": "Root mean square error",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "Sensitivity",
        "label": "Mean absolute error",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "False positive rate",
        "label": "False positive rate",
        "tooltip": "To be completed",
        "type": "numeric"
      }
    ],
    "classification": [
      {
        "code": "Confusion matrix",
        "label": "Confusion matrix",
        "tooltip": "To be completed",
        "type": "confusion_matrix"
      },
      {
        "code": "Accuracy",
        "label": "Accuracy",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "Weighted precision",
        "label": "Weighted Precision",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "Weighted recall",
        "label": "Weighted Recall",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "Weighted F1-score",
        "label": "Weighted F1-score",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "Weighted false positive rate",
        "label": "Weighted false positive rate",
        "tooltip": "To be completed",
        "type": "numeric"
      }
    ],
    "regression": [
      {
        "code": "MSE",
        "label": "Mean square error",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "RMSE",
        "label": "Root mean square error",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "MAE",
        "label": "Mean absolute error",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "R-squared",
        "label": "Coefficient of determination (R²)",
        "tooltip": "To be completed",
        "type": "numeric"
      },
      {
        "code": "Explained variance",
        "label": "Explained variance",
        "tooltip": "To be completed",
        "type": "numeric"
      }
    ]
  },
  "validations": [
    {
      "code": "kFoldCrossValidation",
      "label": "Random k-fold Cross Validation",
      "parameters": [
        {
          "description": "The number of cross-validation fold",
          "label": "Fold",
          "code": "fold",
          "constraints": { "max": 20, "min": 2 },
          "default_value": 5,
          "type": "int"
        }
      ]
    }
  ]
}
